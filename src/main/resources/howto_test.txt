Пример: я описал вам выше цепочку вызовов, соответственно должен быть тест, который отправит на вход json, проверит что приложение его получило. Далее должен быть тест проверки, что этот json корректно распарсился и записался в класс корректно (проверка по данным, находящимся в классе), далее что на класс с такими данными получили вывод и тд.
Тут все зависит от того, как у вас будет код.
5а) Проверять по 1/2 метода смысла нет, надо, чтоб один тест проверял какой-то конечный вариант использования.
Пример: получение корректного json, получение некорректного json на вход, парсинг json в класс.
5б) По итогу весь код должен быть покрыт тестами. У меня в intellij при нажатии на папку с тестами внутри проекта есть опция "run 'al tests' with coverage". в этом случае ваши классы будут проверены на покрытие тестами и будет показано какие строки не покрыты или покрыты не полностью




5в) тесты работают не с конкретно вашим запущенным приложением а с mock-ами, посмотрите как это делается:).
Если пример, то могу дать такой: например, у вас есть класс SomeResource, в нем обработка url-ов. Он принимает с них параметры и передает это в SomeService, который делает дальнейшие действия.

Внутри класса SomeResource может быть что-то такое:

    @Autowired
    private SomeService service;

    @GET
    @Path("/url")
    @AddHeader(name = "Cache-Control", value = "public, max-age=3600")
    @Produces(APPLICATION_JSON)
    @ApiOperation(
            value = "Описание",
            response = SomeClass.class, //это класс который потом переведется в json
            responseContainer = "List", // тип возврата. это значит мы собираемся вернуть List<SomeClass>
            nickname = "getSomeRequest")
    public Response getSomeRequest(
            @ApiParam(value = "Булевый параметр")
            @QueryParam("isTrue") final Boolean isTrue
    ) {
                return someService.getSomeRequest(isTrue)
                    ? Response.ok().build()
                    : Response.status(Response.Status.NOT_FOUND).entity("Not found").build();
    }

Класс тестов SomeResourceTest может содержать следующие поля:

    @Mock
    private SomeService service;

    @InjectMocks
    private SomeResource resource = new SomeResource();

    @Before
    public void setUp() {
        initMocks(this);
    }

И вот в этом классе нам нужно по факту проверить следующее: наш класс принял параметр в url и осуществил его передачу в сервис. Представим что в этом url был какой-то параметр. Тогда тест может выглядеть так:

    @Test
    public void getSomeRequestTest() {
        resource.getSomeRequest(any());
        verify(service).getSomeRequest(any());
    }

Здесь мы проверили, что когда вызывается метод getSomeRequest с параметром, то он производит передачу параметра в следующий класс SomeService для дальнейшей обработки.
Хоть тут нет явной проверки, что он без искажений передал именно введенный нами параметр, можно иногда пренебречь некоторыми мелочами